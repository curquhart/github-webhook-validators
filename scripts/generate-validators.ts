// linter is saying these are all unpublished. TODO: look into why that is.
import * as fs from 'fs';
// eslint-disable-next-line node/no-unpublished-import
import { pascalCase } from 'pascal-case';
// eslint-disable-next-line node/no-unpublished-import
import * as prettier from 'prettier';
// eslint-disable-next-line node/no-unpublished-import
import {default as TypeWriter, KeyPath} from '@gimenete/type-writer';
// eslint-disable-next-line node/no-unpublished-require
const webhooks = require('@octokit/webhooks-definitions') as Array<{ name: string; actions: Array<string>; examples: Array<Record<string, unknown>> }>;

const tw = new TypeWriter();

webhooks.forEach(({ name, examples }) => {
  if (!examples) {
    return;
  }

  const typeName = `WebhookPayload${pascalCase(name)}`;
  tw.add(examples, {
    rootTypeName: typeName,
    namedKeyPaths: {
      [`${typeName}.repository`]: 'PayloadRepository',
      // This prevents a naming colision between the payload of a `installation_repositories` event
      // and the `repositories` attribute of a `installation` event
      'WebhookPayloadInstallation.repositories':
        'WebhookPayloadInstallation_Repositories'
    }
  });
});

const generateValidatorDefinitions = (): string => {
  return tw.typeNames.map(name => `function is${name}(input: unknown): input is webhooks.${name}`).join('\n');
};

const generateValidator = (keyPath: KeyPath, jsPath: string, name?: string, isRequired?: boolean): string => {
  let body = '';
  if (keyPath.required === false || isRequired === false) {
    body += `${jsPath} === undefined || `;
  }
  if (keyPath['object']) {
    if (name !== undefined && tw.typeNames.indexOf(name) !== -1) {
      body += `exports.is${name}(${jsPath}) || `;
    }
    else {
      body += `(typeof ${jsPath} === 'object' && ${jsPath} !== null`;

      for (const [innerName, innerOpts] of Object.entries(keyPath['object'])) {
        body += ` && (${generateValidator(tw.keypaths[innerOpts.keypath], `${jsPath}['${innerName}']`, innerOpts.keypath, innerOpts.required)})`;
        body = body.replace(/ && \(\)$/, '');
      }
      body += ')';
    }
  }
  if (keyPath['null']) {
    body += `${jsPath} === null || `;
  }
  if (keyPath['string']) {
    body += `typeof ${jsPath} === 'string' || `;
  }
  if (keyPath['number']) {
    body += `typeof ${jsPath} === 'number' || `;
  }
  if (keyPath['boolean']) {
    body += `typeof ${jsPath} === 'boolean' || `;
  }
  if (keyPath['array']) {
    body += '(';
    body += `Array.isArray(${jsPath})`;
    // if (subKp['array']['[]']) {
    //   body += `(() => { for (const item of input['${innerName}']) {`;
    // }
    body += ') || ';
  }

  body = body.replace(/ \|\| $/, '');

  return body;
};

const generateValidatorWithReturn = (keyPath: KeyPath): string => {
  return `return ${generateValidator(keyPath, 'input')}`;
};

const generateValidators = (): string => {
  return tw.typeNames.map(name => `exports.is${name} = function(input) {\n${generateValidatorWithReturn(tw.keypaths[name])}\n }`).join('\n');
};

const definition = `
// DO NOT EDIT THIS FILE DIRECTLY
// make edits in scripts/generate-validators.js

import webhooks = require("@octokit/webhooks");

declare namespace WebhookValidators {
  ${generateValidatorDefinitions()}
}

export = WebhookValidators
`;

const validators = `
// DO NOT EDIT THIS FILE DIRECTLY
// make edits in scripts/generate-validators.js

${generateValidators()}

`;

const typesFilepath = 'index.d.ts';
const typesOutput = prettier.format(definition, { filepath: typesFilepath });
fs.writeFileSync(typesFilepath, typesOutput);

const validatorsFilepath = 'index.js';
const validatorsOutput = prettier.format(validators, { filepath: validatorsFilepath });
fs.writeFileSync(validatorsFilepath, validatorsOutput);
